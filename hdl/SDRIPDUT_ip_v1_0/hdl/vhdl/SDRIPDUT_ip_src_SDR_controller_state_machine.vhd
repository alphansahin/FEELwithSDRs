-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\SDRIP\SDRIPDUT_ip_src_SDR_controller_state_machine.vhd
-- Created: 2022-06-06 21:52:42
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: SDRIPDUT_ip_src_SDR_controller_state_machine
-- Source Path: SDRIP/SDR IP DUT/SDR controller state machine
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY SDRIPDUT_ip_src_SDR_controller_state_machine IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        startTimers                       :   IN    std_logic;
        timerRX                           :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        timerPC                           :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        timerTX                           :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        configuration_rsvd                :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
        enableTX                          :   OUT   std_logic;
        enableRX                          :   OUT   std_logic;
        isMode2                           :   OUT   std_logic;
        stateTimer                        :   OUT   std_logic_vector(1 DOWNTO 0);  -- ufix2
        cntDetectionAsMode1               :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        cntDetectionAsMode2               :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        timerRXCurrent                    :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        timerPCCurrent                    :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        timerTXCurrent                    :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        configurationCurrent              :   OUT   std_logic_vector(1 DOWNTO 0)  -- ufix2
        );
END SDRIPDUT_ip_src_SDR_controller_state_machine;


ARCHITECTURE rtl OF SDRIPDUT_ip_src_SDR_controller_state_machine IS

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL timerRX_unsigned                 : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL timerPC_unsigned                 : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL timerTX_unsigned                 : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL configuration_unsigned           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL stateTimer_tmp                   : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL cntDetectionAsMode1_tmp          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL cntDetectionAsMode2_tmp          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL timerRXCurrent_tmp               : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL timerPCCurrent_tmp               : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL timerTXCurrent_tmp               : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL configurationCurrent_tmp         : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL cntMode1_reg                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL cntMode2_reg                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL TimerState_reg                   : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL timerRX_reg                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL timerPC_reg                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL timerTX_reg                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL configuration_reg                : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL startTimers_reg                  : std_logic;
  SIGNAL cntMode1_reg_next                : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL cntMode2_reg_next                : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL TimerState_reg_next              : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL timerRX_reg_next                 : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL timerPC_reg_next                 : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL timerTX_reg_next                 : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL configuration_reg_next           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL startTimers_reg_next             : std_logic;

BEGIN
  timerRX_unsigned <= unsigned(timerRX);

  timerPC_unsigned <= unsigned(timerPC);

  timerTX_unsigned <= unsigned(timerTX);

  configuration_unsigned <= unsigned(configuration_rsvd);

  SDR_controller_state_machine_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        cntMode1_reg <= to_unsigned(16#00000000#, 32);
        cntMode2_reg <= to_unsigned(16#00000000#, 32);
        TimerState_reg <= to_unsigned(16#0#, 2);
        timerRX_reg <= to_unsigned(16#00000200#, 32);
        timerPC_reg <= to_unsigned(16#00000200#, 32);
        timerTX_reg <= to_unsigned(16#00000200#, 32);
        configuration_reg <= to_unsigned(16#0#, 2);
        startTimers_reg <= '0';
      ELSIF enb = '1' THEN
        cntMode1_reg <= cntMode1_reg_next;
        cntMode2_reg <= cntMode2_reg_next;
        TimerState_reg <= TimerState_reg_next;
        timerRX_reg <= timerRX_reg_next;
        timerPC_reg <= timerPC_reg_next;
        timerTX_reg <= timerTX_reg_next;
        configuration_reg <= configuration_reg_next;
        startTimers_reg <= startTimers_reg_next;
      END IF;
    END IF;
  END PROCESS SDR_controller_state_machine_process;

  SDR_controller_state_machine_output : PROCESS (TimerState_reg, cntMode1_reg, cntMode2_reg, configuration_reg,
       configuration_unsigned, startTimers, startTimers_reg, timerPC_reg,
       timerPC_unsigned, timerRX_reg, timerRX_unsigned, timerTX_reg,
       timerTX_unsigned)
  BEGIN
    cntMode1_reg_next <= cntMode1_reg;
    cntMode2_reg_next <= cntMode2_reg;
    TimerState_reg_next <= TimerState_reg;
    timerRX_reg_next <= timerRX_reg;
    timerPC_reg_next <= timerPC_reg;
    timerTX_reg_next <= timerTX_reg;
    --    %% Initialize Registers
    --    %% Set outputs
    IF configuration_reg = to_unsigned(16#1#, 2) THEN 
      IF TimerState_reg = to_unsigned(16#1#, 2) THEN 
        enableRX <= '1';
      ELSE 
        enableRX <= '0';
      END IF;
      IF TimerState_reg = to_unsigned(16#3#, 2) THEN 
        enableTX <= '1';
      ELSE 
        enableTX <= '0';
      END IF;
    ELSIF configuration_reg = to_unsigned(16#2#, 2) THEN 
      IF TimerState_reg /= to_unsigned(16#2#, 2) THEN 
        enableRX <= '1';
      ELSE 
        enableRX <= '0';
      END IF;
      enableTX <= '1';
    ELSE 
      enableRX <= '1';
      enableTX <= '1';
    END IF;
    --    %% Update Registers
    CASE TimerState_reg IS
      WHEN "00" =>
        timerRX_reg_next <= timerRX_unsigned;
        timerPC_reg_next <= timerPC_unsigned;
        timerTX_reg_next <= timerTX_unsigned;
        IF (hdlcoder_to_stdlogic(configuration_reg = to_unsigned(16#1#, 2)) AND startTimers_reg) = '1' THEN 
          TimerState_reg_next <= to_unsigned(16#1#, 2);
          cntMode1_reg_next <= cntMode1_reg + 1;
        ELSIF (hdlcoder_to_stdlogic(configuration_reg = to_unsigned(16#2#, 2)) AND startTimers_reg) = '1' THEN 
          TimerState_reg_next <= to_unsigned(16#2#, 2);
          cntMode2_reg_next <= cntMode2_reg + 1;
        END IF;
      WHEN "01" =>
        IF timerRX_reg = to_unsigned(0, 32) THEN 
          TimerState_reg_next <= to_unsigned(16#2#, 2);
        ELSE 
          timerRX_reg_next <= timerRX_reg - 1;
        END IF;
      WHEN "10" =>
        IF timerPC_reg = to_unsigned(0, 32) THEN 
          IF configuration_reg = to_unsigned(16#1#, 2) THEN 
            TimerState_reg_next <= to_unsigned(16#3#, 2);
          ELSIF configuration_reg = to_unsigned(16#2#, 2) THEN 
            TimerState_reg_next <= to_unsigned(16#0#, 2);
          END IF;
        ELSE 
          timerPC_reg_next <= timerPC_reg - 1;
        END IF;
      WHEN "11" =>
        IF timerTX_reg = to_unsigned(0, 32) THEN 
          TimerState_reg_next <= to_unsigned(16#0#, 2);
        ELSE 
          timerTX_reg_next <= timerTX_reg - 1;
        END IF;
      WHEN OTHERS => 
        NULL;
    END CASE;
    configuration_reg_next <= configuration_unsigned;
    startTimers_reg_next <= startTimers;
    IF configuration_reg = to_unsigned(16#2#, 2) THEN 
      isMode2 <= '1';
    ELSE 
      isMode2 <= '0';
    END IF;
    stateTimer_tmp <= TimerState_reg;
    cntDetectionAsMode1_tmp <= cntMode1_reg;
    cntDetectionAsMode2_tmp <= cntMode2_reg;
    timerRXCurrent_tmp <= timerRX_reg;
    timerPCCurrent_tmp <= timerPC_reg;
    timerTXCurrent_tmp <= timerTX_reg;
    configurationCurrent_tmp <= configuration_reg;
  END PROCESS SDR_controller_state_machine_output;


  stateTimer <= std_logic_vector(stateTimer_tmp);

  cntDetectionAsMode1 <= std_logic_vector(cntDetectionAsMode1_tmp);

  cntDetectionAsMode2 <= std_logic_vector(cntDetectionAsMode2_tmp);

  timerRXCurrent <= std_logic_vector(timerRXCurrent_tmp);

  timerPCCurrent <= std_logic_vector(timerPCCurrent_tmp);

  timerTXCurrent <= std_logic_vector(timerTXCurrent_tmp);

  configurationCurrent <= std_logic_vector(configurationCurrent_tmp);

END rtl;

