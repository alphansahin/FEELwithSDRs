-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\SDRIP\SDRIPDUT_ip_src_Xcorr_with_a_binary_sequence_s_a_s_b.vhd
-- Created: 2022-06-06 21:52:42
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: SDRIPDUT_ip_src_Xcorr_with_a_binary_sequence_s_a_s_b
-- Source Path: SDRIP/SDR IP DUT/Xcorr with a binary sequence (<s,a>, <s,b>)
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.SDRIPDUT_ip_src_SDR_IP_DUT_pkg.ALL;

ENTITY SDRIPDUT_ip_src_Xcorr_with_a_binary_sequence_s_a_s_b IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        inputI                            :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18
        inputQ                            :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18
        enableCorr                        :   IN    std_logic;
        resultI                           :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18
        resultQ                           :   OUT   std_logic_vector(17 DOWNTO 0)  -- sfix18
        );
END SDRIPDUT_ip_src_Xcorr_with_a_binary_sequence_s_a_s_b;


ARCHITECTURE rtl OF SDRIPDUT_ip_src_Xcorr_with_a_binary_sequence_s_a_s_b IS

  -- Constants
  CONSTANT nc                             : vector_of_signed8(0 TO 63) := 
    (to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#01#, 8),
     to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#01#, 8),
     to_signed(16#00#, 8), to_signed(16#00#, 8), to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#00#, 8),
     to_signed(16#00#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8),
     to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#01#, 8),
     to_signed(16#01#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8),
     to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#01#, 8),
     to_signed(16#01#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8),
     to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8),
     to_signed(16#00#, 8), to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8),
     to_signed(16#00#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8),
     to_signed(16#00#, 8), to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8),
     to_signed(16#01#, 8), to_signed(16#01#, 8), to_signed(16#00#, 8), to_signed(16#00#, 8));  -- int8 [64]

  -- Signals
  SIGNAL inputI_signed                    : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL inputQ_signed                    : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL resultI_tmp                      : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL resultQ_tmp                      : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL delayOutputsI                    : vector_of_signed18(0 TO 63);  -- sfix18 [64]
  SIGNAL delayOutputsQ                    : vector_of_signed18(0 TO 63);  -- sfix18 [64]
  SIGNAL delayOutputsI_next               : vector_of_signed18(0 TO 63);  -- sfix18 [64]
  SIGNAL delayOutputsQ_next               : vector_of_signed18(0 TO 63);  -- sfix18 [64]

BEGIN
  inputI_signed <= signed(inputI);

  inputQ_signed <= signed(inputQ);

  Xcorr_with_a_binary_sequence_s_a_s_b_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayOutputsI <= (OTHERS => to_signed(16#00000#, 18));
        delayOutputsQ <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb = '1' THEN
        delayOutputsI <= delayOutputsI_next;
        delayOutputsQ <= delayOutputsQ_next;
      END IF;
    END IF;
  END PROCESS Xcorr_with_a_binary_sequence_s_a_s_b_process;

  Xcorr_with_a_binary_sequence_s_a_s_b_output : PROCESS (delayOutputsI, delayOutputsQ, enableCorr, inputI_signed, inputQ_signed)
    VARIABLE sumsResultsI : vector_of_signed18(0 TO 62);
    VARIABLE sumsResultsQ : vector_of_signed18(0 TO 62);
    VARIABLE yfi : signed(17 DOWNTO 0);
    VARIABLE yfi_0 : signed(17 DOWNTO 0);
    VARIABLE t_0 : signed(18 DOWNTO 0);
    VARIABLE t_1 : signed(18 DOWNTO 0);
  BEGIN
    delayOutputsI_next <= delayOutputsI;
    delayOutputsQ_next <= delayOutputsQ;
    --    %% Registers
    --    %% Set outputs
    --    %% Update registers
    t_0 :=  - (resize(inputI_signed, 19));
    yfi := t_0(17 DOWNTO 0);
    t_1 :=  - (resize(inputQ_signed, 19));
    yfi_0 := t_1(17 DOWNTO 0);

    FOR indSumResult IN 0 TO 62 LOOP
      IF nc(indSumResult + 1) = to_signed(16#00000001#, 8) THEN 
        sumsResultsI(indSumResult) := delayOutputsI(indSumResult) + inputI_signed;
        sumsResultsQ(indSumResult) := delayOutputsQ(indSumResult) + inputQ_signed;
      ELSE 
        sumsResultsI(indSumResult) := delayOutputsI(indSumResult) + yfi;
        sumsResultsQ(indSumResult) := delayOutputsQ(indSumResult) + yfi_0;
      END IF;
    END LOOP;

    IF enableCorr = '1' THEN 
      delayOutputsI_next(0) <= inputI_signed;
      delayOutputsQ_next(0) <= inputQ_signed;
      delayOutputsI_next(1 TO 63) <= sumsResultsI(0 TO 62);
      delayOutputsQ_next(1 TO 63) <= sumsResultsQ(0 TO 62);
    END IF;
    resultI_tmp <= delayOutputsI(63);
    resultQ_tmp <= delayOutputsQ(63);
  END PROCESS Xcorr_with_a_binary_sequence_s_a_s_b_output;


  resultI <= std_logic_vector(resultI_tmp);

  resultQ <= std_logic_vector(resultQ_tmp);

END rtl;

