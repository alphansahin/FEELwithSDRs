-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\SDRIP\SDRIPDUT_ip_src_Accumulator.vhd
-- Created: 2022-06-06 21:52:42
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: SDRIPDUT_ip_src_Accumulator
-- Source Path: SDRIP/SDR IP DUT/Accumulator
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.SDRIPDUT_ip_src_SDR_IP_DUT_pkg.ALL;

ENTITY SDRIPDUT_ip_src_Accumulator IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        energyIn                          :   IN    std_logic_vector(24 DOWNTO 0);  -- ufix25
        enableCorr                        :   IN    std_logic;
        result                            :   OUT   std_logic_vector(30 DOWNTO 0)  -- ufix31
        );
END SDRIPDUT_ip_src_Accumulator;


ARCHITECTURE rtl OF SDRIPDUT_ip_src_Accumulator IS

  -- Signals
  SIGNAL energyIn_unsigned                : unsigned(24 DOWNTO 0);  -- ufix25
  SIGNAL result_tmp                       : unsigned(30 DOWNTO 0);  -- ufix31
  SIGNAL delayOutputs                     : vector_of_unsigned25(0 TO 63);  -- ufix25 [64]
  SIGNAL energy                           : unsigned(30 DOWNTO 0);  -- ufix31
  SIGNAL delayOutputs_next                : vector_of_unsigned25(0 TO 63);  -- ufix25 [64]
  SIGNAL energy_next                      : unsigned(30 DOWNTO 0);  -- ufix31

BEGIN
  energyIn_unsigned <= unsigned(energyIn);

  Accumulator_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayOutputs <= (OTHERS => to_unsigned(16#0000000#, 25));
        energy <= to_unsigned(16#00000000#, 31);
      ELSIF enb = '1' THEN
        delayOutputs <= delayOutputs_next;
        energy <= energy_next;
      END IF;
    END IF;
  END PROCESS Accumulator_process;

  Accumulator_output : PROCESS (delayOutputs, enableCorr, energy, energyIn_unsigned)
    VARIABLE energyOut : unsigned(24 DOWNTO 0);
  BEGIN
    delayOutputs_next <= delayOutputs;
    energy_next <= energy;
    --    %% Registers
    --energyIn = fi(energyIn,0,numberOfBitsDelay,0,'RoundingMethod','floor', 'SumMode','FullPrecision','ProductMode','FullPrecision'); 
    --    %% Set outputs
    --    %% Update registers
    energyOut := delayOutputs(63);
    IF enableCorr = '1' THEN 
      delayOutputs_next(1 TO 63) <= delayOutputs(0 TO 62);
      delayOutputs_next(0) <= energyIn_unsigned;
      energy_next <= resize(resize(resize(energy, 29), 30) + resize(energyIn_unsigned, 30), 31) - resize(energyOut, 31);
      -- Full implementation
    END IF;
    result_tmp <= energy;
  END PROCESS Accumulator_output;


  result <= std_logic_vector(result_tmp);

END rtl;

